
as.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000001e  00800100  000004e2  00000576  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000004e2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000007d2  0080011e  0080011e  00000594  2**0
                  ALLOC
  3 .debug_aranges 00000040  00000000  00000000  00000594  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 0000015a  00000000  00000000  000005d4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000006ee  00000000  00000000  0000072e  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000002ce  00000000  00000000  00000e1c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000554  00000000  00000000  000010ea  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000110  00000000  00000000  00001640  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000216  00000000  00000000  00001750  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000026c  00000000  00000000  00001966  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000048  00000000  00000000  00001bd2  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 46 00 	jmp	0x8c	; 0x8c <__ctors_end>
   4:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
   8:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
   c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  10:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  14:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  18:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  1c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  20:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  24:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  28:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  2c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  30:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  34:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  38:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  3c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  40:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  44:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  48:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__vector_18>
  4c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  50:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  54:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  58:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  5c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  60:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  64:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  68:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  6c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  70:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  74:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  78:	0c 94 2f 01 	jmp	0x25e	; 0x25e <__vector_30>
  7c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  80:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  84:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  88:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>

0000008c <__ctors_end>:
  8c:	11 24       	eor	r1, r1
  8e:	1f be       	out	0x3f, r1	; 63
  90:	cf ef       	ldi	r28, 0xFF	; 255
  92:	d0 e1       	ldi	r29, 0x10	; 16
  94:	de bf       	out	0x3e, r29	; 62
  96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
  98:	11 e0       	ldi	r17, 0x01	; 1
  9a:	a0 e0       	ldi	r26, 0x00	; 0
  9c:	b1 e0       	ldi	r27, 0x01	; 1
  9e:	e2 ee       	ldi	r30, 0xE2	; 226
  a0:	f4 e0       	ldi	r31, 0x04	; 4
  a2:	00 e0       	ldi	r16, 0x00	; 0
  a4:	0b bf       	out	0x3b, r16	; 59
  a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
  a8:	07 90       	elpm	r0, Z+
  aa:	0d 92       	st	X+, r0
  ac:	ae 31       	cpi	r26, 0x1E	; 30
  ae:	b1 07       	cpc	r27, r17
  b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
  b2:	18 e0       	ldi	r17, 0x08	; 8
  b4:	ae e1       	ldi	r26, 0x1E	; 30
  b6:	b1 e0       	ldi	r27, 0x01	; 1
  b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
  ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
  bc:	a0 3f       	cpi	r26, 0xF0	; 240
  be:	b1 07       	cpc	r27, r17
  c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
  c2:	0e 94 db 00 	call	0x1b6	; 0x1b6 <main>
  c6:	0c 94 6f 02 	jmp	0x4de	; 0x4de <_exit>

000000ca <__bad_interrupt>:
  ca:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ce <UART0_Init>:
}


void UART0_Init(void)
{
  UBRR0H = 0;//baud = 9600!!
  ce:	10 92 90 00 	sts	0x0090, r1
  UBRR0L = 207;//baud = 9600!
  d2:	8f ec       	ldi	r24, 0xCF	; 207
  d4:	89 b9       	out	0x09, r24	; 9
  UCSR0A = 0x02;                  //asynchronous normal mode
  d6:	82 e0       	ldi	r24, 0x02	; 2
  d8:	8b b9       	out	0x0b, r24	; 11
  UCSR0B = (1<<RXCIE0)|(1<<RXEN0)|(1<<TXEN0); //interrupt, Rx/Tx enable
  da:	88 e9       	ldi	r24, 0x98	; 152
  dc:	8a b9       	out	0x0a, r24	; 10
  UCSR0C = (1<<UCSZ01)|(1<<UCSZ00);//no parity, 1 stop, 8 data
  de:	86 e0       	ldi	r24, 0x06	; 6
  e0:	80 93 95 00 	sts	0x0095, r24
}
  e4:	08 95       	ret

000000e6 <UART1_Init>:

void UART1_Init(void)
{
  UBRR1H = 0;//baud = 9600!!
  e6:	10 92 98 00 	sts	0x0098, r1
  UBRR1L = 207;//baud = 9600!!
  ea:	8f ec       	ldi	r24, 0xCF	; 207
  ec:	80 93 99 00 	sts	0x0099, r24
  UCSR1A = 0x02;                  //asynchronous normal mode
  f0:	82 e0       	ldi	r24, 0x02	; 2
  f2:	80 93 9b 00 	sts	0x009B, r24
  UCSR1B = (1<<RXCIE1)|(1<<RXEN1)|(1<<TXEN1); //interrupt, Rx/Tx enable
  f6:	88 e9       	ldi	r24, 0x98	; 152
  f8:	80 93 9a 00 	sts	0x009A, r24
  UCSR1C = (1<<UCSZ11)|(1<<UCSZ10);//no parity, 1 stop, 8 data
  fc:	86 e0       	ldi	r24, 0x06	; 6
  fe:	80 93 9d 00 	sts	0x009D, r24
}
 102:	08 95       	ret

00000104 <UART0_Read_Byte>:

void UART0_Read_Byte(unsigned char data)
{
  while(!(UCSR0A & (1<<UDRE0)));  //wait for empty transmit buffer
 104:	5d 9b       	sbis	0x0b, 5	; 11
 106:	fe cf       	rjmp	.-4      	; 0x104 <UART0_Read_Byte>
  UDR0 = data;                    //put data into buffer, send the data
 108:	8c b9       	out	0x0c, r24	; 12
}
 10a:	08 95       	ret

0000010c <UART1_Read_Byte>:

void UART1_Read_Byte(unsigned char data)
{
 10c:	98 2f       	mov	r25, r24
  while(!(UCSR1A & (1<<UDRE1)));  //wait for empty transmit buffer
 10e:	80 91 9b 00 	lds	r24, 0x009B
 112:	85 ff       	sbrs	r24, 5
 114:	fc cf       	rjmp	.-8      	; 0x10e <UART1_Read_Byte+0x2>
  UDR1 = data;                    //put data into buffer, send the data
 116:	90 93 9c 00 	sts	0x009C, r25
}
 11a:	08 95       	ret

0000011c <print>:

void print(unsigned char *message)
{
 11c:	fc 01       	movw	r30, r24
 11e:	0a c0       	rjmp	.+20     	; 0x134 <print+0x18>
  UCSR1C = (1<<UCSZ11)|(1<<UCSZ10);//no parity, 1 stop, 8 data
}

void UART0_Read_Byte(unsigned char data)
{
  while(!(UCSR0A & (1<<UDRE0)));  //wait for empty transmit buffer
 120:	5d 9b       	sbis	0x0b, 5	; 11
 122:	fe cf       	rjmp	.-4      	; 0x120 <print+0x4>
  UDR0 = data;                    //put data into buffer, send the data
 124:	9c b9       	out	0x0c, r25	; 12
}

void UART1_Read_Byte(unsigned char data)
{
  while(!(UCSR1A & (1<<UDRE1)));  //wait for empty transmit buffer
 126:	80 91 9b 00 	lds	r24, 0x009B
 12a:	85 ff       	sbrs	r24, 5
 12c:	fc cf       	rjmp	.-8      	; 0x126 <print+0xa>
  UDR1 = data;                    //put data into buffer, send the data
 12e:	90 93 9c 00 	sts	0x009C, r25
void print(unsigned char *message)
{
  while(*message != '\0'){
    UART0_Read_Byte(*message);
    UART1_Read_Byte(*message);
    message++;
 132:	31 96       	adiw	r30, 0x01	; 1
  UDR1 = data;                    //put data into buffer, send the data
}

void print(unsigned char *message)
{
  while(*message != '\0'){
 134:	90 81       	ld	r25, Z
 136:	99 23       	and	r25, r25
 138:	99 f7       	brne	.-26     	; 0x120 <print+0x4>
 13a:	07 c0       	rjmp	.+14     	; 0x14a <print+0x2e>
  UDR0 = data;                    //put data into buffer, send the data
}

void UART1_Read_Byte(unsigned char data)
{
  while(!(UCSR1A & (1<<UDRE1)));  //wait for empty transmit buffer
 13c:	80 91 9b 00 	lds	r24, 0x009B
 140:	85 ff       	sbrs	r24, 5
 142:	fc cf       	rjmp	.-8      	; 0x13c <print+0x20>
  UDR1 = data;                    //put data into buffer, send the data
 144:	90 93 9c 00 	sts	0x009C, r25
    message++;
  }
	
  while(*message != '\0'){
    UART1_Read_Byte(*message);
    message++;
 148:	31 96       	adiw	r30, 0x01	; 1
    UART0_Read_Byte(*message);
    UART1_Read_Byte(*message);
    message++;
  }
	
  while(*message != '\0'){
 14a:	90 81       	ld	r25, Z
 14c:	99 23       	and	r25, r25
 14e:	b1 f7       	brne	.-20     	; 0x13c <print+0x20>
    UART1_Read_Byte(*message);
    message++;
  }
}
 150:	08 95       	ret

00000152 <UI_Handler>:

void UI_Handler(unsigned char *qdata)
{
  if(receive_completion){
 152:	80 91 1e 01 	lds	r24, 0x011E
 156:	88 23       	and	r24, r24
 158:	69 f1       	breq	.+90     	; 0x1b4 <UI_Handler+0x62>
    receive_completion = 0;
 15a:	10 92 1e 01 	sts	0x011E, r1
    switch(receive_data){
 15e:	80 91 ef 08 	lds	r24, 0x08EF
 162:	8a 30       	cpi	r24, 0x0A	; 10
 164:	49 f0       	breq	.+18     	; 0x178 <UI_Handler+0x26>
 166:	8d 30       	cpi	r24, 0x0D	; 13
 168:	a1 f4       	brne	.+40     	; 0x192 <UI_Handler+0x40>
  UCSR1C = (1<<UCSZ11)|(1<<UCSZ10);//no parity, 1 stop, 8 data
}

void UART0_Read_Byte(unsigned char data)
{
  while(!(UCSR0A & (1<<UDRE0)));  //wait for empty transmit buffer
 16a:	5d 9b       	sbis	0x0b, 5	; 11
 16c:	fe cf       	rjmp	.-4      	; 0x16a <UI_Handler+0x18>
  UDR0 = data;                    //put data into buffer, send the data
 16e:	8d e0       	ldi	r24, 0x0D	; 13
 170:	8c b9       	out	0x0c, r24	; 12
  UCSR1C = (1<<UCSZ11)|(1<<UCSZ10);//no parity, 1 stop, 8 data
}

void UART0_Read_Byte(unsigned char data)
{
  while(!(UCSR0A & (1<<UDRE0)));  //wait for empty transmit buffer
 172:	5d 9b       	sbis	0x0b, 5	; 11
 174:	fe cf       	rjmp	.-4      	; 0x172 <UI_Handler+0x20>
 176:	06 c0       	rjmp	.+12     	; 0x184 <UI_Handler+0x32>
  UDR0 = data;                    //put data into buffer, send the data
 178:	5d 9b       	sbis	0x0b, 5	; 11
 17a:	fe cf       	rjmp	.-4      	; 0x178 <UI_Handler+0x26>
 17c:	8d e0       	ldi	r24, 0x0D	; 13
 17e:	8c b9       	out	0x0c, r24	; 12
  UCSR1C = (1<<UCSZ11)|(1<<UCSZ10);//no parity, 1 stop, 8 data
}

void UART0_Read_Byte(unsigned char data)
{
  while(!(UCSR0A & (1<<UDRE0)));  //wait for empty transmit buffer
 180:	5d 9b       	sbis	0x0b, 5	; 11
 182:	fe cf       	rjmp	.-4      	; 0x180 <UI_Handler+0x2e>
  UDR0 = data;                    //put data into buffer, send the data
 184:	8a e0       	ldi	r24, 0x0A	; 10
 186:	8c b9       	out	0x0c, r24	; 12
    switch(receive_data){
        case '\r' : UART0_Read_Byte('\r'); UART0_Read_Byte('\n');
                    print(prompt);
                    break;
        case '\n' : UART0_Read_Byte('\r'); UART0_Read_Byte('\n');
                    print(prompt);
 188:	80 e0       	ldi	r24, 0x00	; 0
 18a:	91 e0       	ldi	r25, 0x01	; 1
 18c:	0e 94 8e 00 	call	0x11c	; 0x11c <print>
 190:	08 95       	ret
                    break;
        default   : UART0_Read_Byte(receive_data);
 192:	80 91 ef 08 	lds	r24, 0x08EF
  UCSR1C = (1<<UCSZ11)|(1<<UCSZ10);//no parity, 1 stop, 8 data
}

void UART0_Read_Byte(unsigned char data)
{
  while(!(UCSR0A & (1<<UDRE0)));  //wait for empty transmit buffer
 196:	5d 9b       	sbis	0x0b, 5	; 11
 198:	fe cf       	rjmp	.-4      	; 0x196 <UI_Handler+0x44>
  UDR0 = data;                    //put data into buffer, send the data
 19a:	8c b9       	out	0x0c, r24	; 12
  UCSR1C = (1<<UCSZ11)|(1<<UCSZ10);//no parity, 1 stop, 8 data
}

void UART0_Read_Byte(unsigned char data)
{
  while(!(UCSR0A & (1<<UDRE0)));  //wait for empty transmit buffer
 19c:	5d 9b       	sbis	0x0b, 5	; 11
 19e:	fe cf       	rjmp	.-4      	; 0x19c <UI_Handler+0x4a>
  UDR0 = data;                    //put data into buffer, send the data
 1a0:	8d e0       	ldi	r24, 0x0D	; 13
 1a2:	8c b9       	out	0x0c, r24	; 12
  UCSR1C = (1<<UCSZ11)|(1<<UCSZ10);//no parity, 1 stop, 8 data
}

void UART0_Read_Byte(unsigned char data)
{
  while(!(UCSR0A & (1<<UDRE0)));  //wait for empty transmit buffer
 1a4:	5d 9b       	sbis	0x0b, 5	; 11
 1a6:	fe cf       	rjmp	.-4      	; 0x1a4 <UI_Handler+0x52>
  UDR0 = data;                    //put data into buffer, send the data
 1a8:	8a e0       	ldi	r24, 0x0A	; 10
 1aa:	8c b9       	out	0x0c, r24	; 12
        case '\n' : UART0_Read_Byte('\r'); UART0_Read_Byte('\n');
                    print(prompt);
                    break;
        default   : UART0_Read_Byte(receive_data);
                    UART0_Read_Byte('\r'); UART0_Read_Byte('\n');
                    print(prompt);
 1ac:	80 e0       	ldi	r24, 0x00	; 0
 1ae:	91 e0       	ldi	r25, 0x01	; 1
 1b0:	0e 94 8e 00 	call	0x11c	; 0x11c <print>
 1b4:	08 95       	ret

000001b6 <main>:
unsigned char rbuf[2000] = {0};



int main(void)
{
 1b6:	ef 92       	push	r14
 1b8:	ff 92       	push	r15
 1ba:	0f 93       	push	r16
 1bc:	1f 93       	push	r17
 1be:	df 93       	push	r29
 1c0:	cf 93       	push	r28
 1c2:	cd b7       	in	r28, 0x3d	; 61
 1c4:	de b7       	in	r29, 0x3e	; 62
 1c6:	c6 59       	subi	r28, 0x96	; 150
 1c8:	d0 40       	sbci	r29, 0x00	; 0
 1ca:	0f b6       	in	r0, 0x3f	; 63
 1cc:	f8 94       	cli
 1ce:	de bf       	out	0x3e, r29	; 62
 1d0:	0f be       	out	0x3f, r0	; 63
 1d2:	cd bf       	out	0x3d, r28	; 61
  UCSR0C = (1<<UCSZ01)|(1<<UCSZ00);//no parity, 1 stop, 8 data
}

void UART1_Init(void)
{
  UBRR1H = 0;//baud = 9600!!
 1d4:	10 92 98 00 	sts	0x0098, r1
  UBRR1L = 207;//baud = 9600!!
 1d8:	3f ec       	ldi	r19, 0xCF	; 207
 1da:	30 93 99 00 	sts	0x0099, r19
  UCSR1A = 0x02;                  //asynchronous normal mode
 1de:	22 e0       	ldi	r18, 0x02	; 2
 1e0:	20 93 9b 00 	sts	0x009B, r18
  UCSR1B = (1<<RXCIE1)|(1<<RXEN1)|(1<<TXEN1); //interrupt, Rx/Tx enable
 1e4:	98 e9       	ldi	r25, 0x98	; 152
 1e6:	90 93 9a 00 	sts	0x009A, r25
  UCSR1C = (1<<UCSZ11)|(1<<UCSZ10);//no parity, 1 stop, 8 data
 1ea:	86 e0       	ldi	r24, 0x06	; 6
 1ec:	80 93 9d 00 	sts	0x009D, r24
}


void UART0_Init(void)
{
  UBRR0H = 0;//baud = 9600!!
 1f0:	10 92 90 00 	sts	0x0090, r1
  UBRR0L = 207;//baud = 9600!
 1f4:	39 b9       	out	0x09, r19	; 9
  UCSR0A = 0x02;                  //asynchronous normal mode
 1f6:	2b b9       	out	0x0b, r18	; 11
  UCSR0B = (1<<RXCIE0)|(1<<RXEN0)|(1<<TXEN0); //interrupt, Rx/Tx enable
 1f8:	9a b9       	out	0x0a, r25	; 10
  UCSR0C = (1<<UCSZ01)|(1<<UCSZ00);//no parity, 1 stop, 8 data
 1fa:	80 93 95 00 	sts	0x0095, r24
{

	unsigned char qdata[QBUFFER];
    UART1_Init();  // baud rate : 9600
	UART0_Init();  // baud rate : 9600
    sei();
 1fe:	78 94       	sei
    print(prompt);
 200:	80 e0       	ldi	r24, 0x00	; 0
 202:	91 e0       	ldi	r25, 0x01	; 1
 204:	0e 94 8e 00 	call	0x11c	; 0x11c <print>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 208:	80 e9       	ldi	r24, 0x90	; 144
 20a:	e8 2e       	mov	r14, r24
 20c:	81 e0       	ldi	r24, 0x01	; 1
 20e:	f8 2e       	mov	r15, r24
    
    do{
		print(str1);
		_delay_ms(1000);
		PORTA = ~PORTA;
		UI_Handler(qdata);
 210:	8e 01       	movw	r16, r28
 212:	0f 5f       	subi	r16, 0xFF	; 255
 214:	1f 4f       	sbci	r17, 0xFF	; 255
	UART0_Init();  // baud rate : 9600
    sei();
    print(prompt);
    
    do{
		print(str1);
 216:	8c e0       	ldi	r24, 0x0C	; 12
 218:	91 e0       	ldi	r25, 0x01	; 1
 21a:	0e 94 8e 00 	call	0x11c	; 0x11c <print>
 21e:	80 e1       	ldi	r24, 0x10	; 16
 220:	97 e2       	ldi	r25, 0x27	; 39
 222:	f7 01       	movw	r30, r14
 224:	31 97       	sbiw	r30, 0x01	; 1
 226:	f1 f7       	brne	.-4      	; 0x224 <main+0x6e>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 228:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 22a:	d9 f7       	brne	.-10     	; 0x222 <main+0x6c>
		_delay_ms(1000);
		PORTA = ~PORTA;
 22c:	8b b3       	in	r24, 0x1b	; 27
 22e:	80 95       	com	r24
 230:	8b bb       	out	0x1b, r24	; 27
		UI_Handler(qdata);
 232:	c8 01       	movw	r24, r16
 234:	0e 94 a9 00 	call	0x152	; 0x152 <UI_Handler>
 238:	ee cf       	rjmp	.-36     	; 0x216 <main+0x60>

0000023a <__vector_18>:
  }
  return;
}

SIGNAL(SIG_UART0_RECV)
{
 23a:	1f 92       	push	r1
 23c:	0f 92       	push	r0
 23e:	0f b6       	in	r0, 0x3f	; 63
 240:	0f 92       	push	r0
 242:	11 24       	eor	r1, r1
 244:	8f 93       	push	r24
  receive_data = UDR0;
 246:	8c b1       	in	r24, 0x0c	; 12
 248:	80 93 ef 08 	sts	0x08EF, r24
  receive_completion = 1;
 24c:	81 e0       	ldi	r24, 0x01	; 1
 24e:	80 93 1e 01 	sts	0x011E, r24
}
 252:	8f 91       	pop	r24
 254:	0f 90       	pop	r0
 256:	0f be       	out	0x3f, r0	; 63
 258:	0f 90       	pop	r0
 25a:	1f 90       	pop	r1
 25c:	18 95       	reti

0000025e <__vector_30>:


SIGNAL(SIG_UART1_RECV)
{
 25e:	1f 92       	push	r1
 260:	0f 92       	push	r0
 262:	0f b6       	in	r0, 0x3f	; 63
 264:	0f 92       	push	r0
 266:	11 24       	eor	r1, r1
 268:	8f 93       	push	r24
  unsigned char ret = 0;
  //ret = rbuf[rx_out];


  receive_data = UDR1;
 26a:	80 91 9c 00 	lds	r24, 0x009C
 26e:	80 93 ef 08 	sts	0x08EF, r24
  PORTA = ~PORTA;
 272:	8b b3       	in	r24, 0x1b	; 27
 274:	80 95       	com	r24
 276:	8b bb       	out	0x1b, r24	; 27
  receive_completion = 1;
 278:	81 e0       	ldi	r24, 0x01	; 1
 27a:	80 93 1e 01 	sts	0x011E, r24
}
 27e:	8f 91       	pop	r24
 280:	0f 90       	pop	r0
 282:	0f be       	out	0x3f, r0	; 63
 284:	0f 90       	pop	r0
 286:	1f 90       	pop	r1
 288:	18 95       	reti

0000028a <qbufferInit>:
#include "qbuffer.h"

void qbufferInit(void)
{

}
 28a:	08 95       	ret

0000028c <qbufferCreate>:

bool qbufferCreate(qbuffer_t *p_node, uint8_t *p_buf, uint32_t length)
{
 28c:	fc 01       	movw	r30, r24
  bool ret = true;


  p_node->ptr_in  = 0;
 28e:	10 82       	st	Z, r1
 290:	11 82       	std	Z+1, r1	; 0x01
 292:	12 82       	std	Z+2, r1	; 0x02
 294:	13 82       	std	Z+3, r1	; 0x03
  p_node->ptr_out = 0;
 296:	14 82       	std	Z+4, r1	; 0x04
 298:	15 82       	std	Z+5, r1	; 0x05
 29a:	16 82       	std	Z+6, r1	; 0x06
 29c:	17 82       	std	Z+7, r1	; 0x07
  p_node->length  = length;
 29e:	20 87       	std	Z+8, r18	; 0x08
 2a0:	31 87       	std	Z+9, r19	; 0x09
 2a2:	42 87       	std	Z+10, r20	; 0x0a
 2a4:	53 87       	std	Z+11, r21	; 0x0b
  p_node->p_buf   = p_buf;
 2a6:	75 87       	std	Z+13, r23	; 0x0d
 2a8:	64 87       	std	Z+12, r22	; 0x0c

  if (p_node->p_buf == NULL)
 2aa:	67 2b       	or	r22, r23
 2ac:	11 f0       	breq	.+4      	; 0x2b2 <qbufferCreate+0x26>
 2ae:	81 e0       	ldi	r24, 0x01	; 1
 2b0:	08 95       	ret
  {
    p_node->length = 0;
 2b2:	10 86       	std	Z+8, r1	; 0x08
 2b4:	11 86       	std	Z+9, r1	; 0x09
 2b6:	12 86       	std	Z+10, r1	; 0x0a
 2b8:	13 86       	std	Z+11, r1	; 0x0b
 2ba:	80 e0       	ldi	r24, 0x00	; 0
    ret = false;
  }

  return ret;
}
 2bc:	08 95       	ret

000002be <qbufferWrite>:

bool qbufferWrite(qbuffer_t *p_node, uint8_t *p_data, uint32_t length)
{
 2be:	6f 92       	push	r6
 2c0:	7f 92       	push	r7
 2c2:	8f 92       	push	r8
 2c4:	9f 92       	push	r9
 2c6:	af 92       	push	r10
 2c8:	bf 92       	push	r11
 2ca:	cf 92       	push	r12
 2cc:	df 92       	push	r13
 2ce:	ef 92       	push	r14
 2d0:	ff 92       	push	r15
 2d2:	0f 93       	push	r16
 2d4:	1f 93       	push	r17
 2d6:	cf 93       	push	r28
 2d8:	df 93       	push	r29
 2da:	ec 01       	movw	r28, r24
 2dc:	39 01       	movw	r6, r18
 2de:	4a 01       	movw	r8, r20
  bool ret = true;
  uint32_t index;
  uint32_t next_index;
  uint32_t i;

  if (p_node->p_buf == NULL) return false;
 2e0:	8c 85       	ldd	r24, Y+12	; 0x0c
 2e2:	9d 85       	ldd	r25, Y+13	; 0x0d
 2e4:	89 2b       	or	r24, r25
 2e6:	e9 f1       	breq	.+122    	; 0x362 <qbufferWrite+0xa4>
 2e8:	ee 24       	eor	r14, r14
 2ea:	ff 24       	eor	r15, r15
 2ec:	87 01       	movw	r16, r14
 2ee:	32 c0       	rjmp	.+100    	; 0x354 <qbufferWrite+0x96>


  for (i=0; i<length; i++)
  {
    index      = p_node->ptr_in;
 2f0:	a8 80       	ld	r10, Y
 2f2:	b9 80       	ldd	r11, Y+1	; 0x01
 2f4:	ca 80       	ldd	r12, Y+2	; 0x02
 2f6:	db 80       	ldd	r13, Y+3	; 0x03
    next_index = p_node->ptr_in + 1;
 2f8:	a6 01       	movw	r20, r12
 2fa:	95 01       	movw	r18, r10
 2fc:	2f 5f       	subi	r18, 0xFF	; 255
 2fe:	3f 4f       	sbci	r19, 0xFF	; 255
 300:	4f 4f       	sbci	r20, 0xFF	; 255
 302:	5f 4f       	sbci	r21, 0xFF	; 255

    if (next_index == p_node->length)
 304:	88 85       	ldd	r24, Y+8	; 0x08
 306:	99 85       	ldd	r25, Y+9	; 0x09
 308:	aa 85       	ldd	r26, Y+10	; 0x0a
 30a:	bb 85       	ldd	r27, Y+11	; 0x0b
 30c:	28 17       	cp	r18, r24
 30e:	39 07       	cpc	r19, r25
 310:	4a 07       	cpc	r20, r26
 312:	5b 07       	cpc	r21, r27
 314:	21 f4       	brne	.+8      	; 0x31e <qbufferWrite+0x60>
 316:	20 e0       	ldi	r18, 0x00	; 0
 318:	30 e0       	ldi	r19, 0x00	; 0
 31a:	40 e0       	ldi	r20, 0x00	; 0
 31c:	50 e0       	ldi	r21, 0x00	; 0
    {
      next_index = 0;;
    }

    if (next_index != p_node->ptr_out)
 31e:	8c 81       	ldd	r24, Y+4	; 0x04
 320:	9d 81       	ldd	r25, Y+5	; 0x05
 322:	ae 81       	ldd	r26, Y+6	; 0x06
 324:	bf 81       	ldd	r27, Y+7	; 0x07
 326:	28 17       	cp	r18, r24
 328:	39 07       	cpc	r19, r25
 32a:	4a 07       	cpc	r20, r26
 32c:	5b 07       	cpc	r21, r27
 32e:	c9 f0       	breq	.+50     	; 0x362 <qbufferWrite+0xa4>
    {
      p_node->p_buf[index] = p_data[i];
 330:	ec 85       	ldd	r30, Y+12	; 0x0c
 332:	fd 85       	ldd	r31, Y+13	; 0x0d
 334:	ea 0d       	add	r30, r10
 336:	fb 1d       	adc	r31, r11
 338:	db 01       	movw	r26, r22
 33a:	ae 0d       	add	r26, r14
 33c:	bf 1d       	adc	r27, r15
 33e:	8c 91       	ld	r24, X
 340:	80 83       	st	Z, r24
      p_node->ptr_in       = next_index;
 342:	28 83       	st	Y, r18
 344:	39 83       	std	Y+1, r19	; 0x01
 346:	4a 83       	std	Y+2, r20	; 0x02
 348:	5b 83       	std	Y+3, r21	; 0x03
  uint32_t i;

  if (p_node->p_buf == NULL) return false;


  for (i=0; i<length; i++)
 34a:	08 94       	sec
 34c:	e1 1c       	adc	r14, r1
 34e:	f1 1c       	adc	r15, r1
 350:	01 1d       	adc	r16, r1
 352:	11 1d       	adc	r17, r1
 354:	e6 14       	cp	r14, r6
 356:	f7 04       	cpc	r15, r7
 358:	08 05       	cpc	r16, r8
 35a:	19 05       	cpc	r17, r9
 35c:	48 f2       	brcs	.-110    	; 0x2f0 <qbufferWrite+0x32>
 35e:	81 e0       	ldi	r24, 0x01	; 1
 360:	01 c0       	rjmp	.+2      	; 0x364 <qbufferWrite+0xa6>
 362:	80 e0       	ldi	r24, 0x00	; 0
      break;
    }
  }

  return ret;
}
 364:	df 91       	pop	r29
 366:	cf 91       	pop	r28
 368:	1f 91       	pop	r17
 36a:	0f 91       	pop	r16
 36c:	ff 90       	pop	r15
 36e:	ef 90       	pop	r14
 370:	df 90       	pop	r13
 372:	cf 90       	pop	r12
 374:	bf 90       	pop	r11
 376:	af 90       	pop	r10
 378:	9f 90       	pop	r9
 37a:	8f 90       	pop	r8
 37c:	7f 90       	pop	r7
 37e:	6f 90       	pop	r6
 380:	08 95       	ret

00000382 <qbufferRead>:

bool qbufferRead(qbuffer_t *p_node, uint8_t *p_data, uint32_t length)
{
 382:	6f 92       	push	r6
 384:	7f 92       	push	r7
 386:	8f 92       	push	r8
 388:	9f 92       	push	r9
 38a:	af 92       	push	r10
 38c:	bf 92       	push	r11
 38e:	cf 92       	push	r12
 390:	df 92       	push	r13
 392:	ef 92       	push	r14
 394:	ff 92       	push	r15
 396:	0f 93       	push	r16
 398:	1f 93       	push	r17
 39a:	cf 93       	push	r28
 39c:	df 93       	push	r29
 39e:	ec 01       	movw	r28, r24
 3a0:	39 01       	movw	r6, r18
 3a2:	4a 01       	movw	r8, r20
  bool ret = true;
  uint32_t index;
  uint32_t next_index;
  uint32_t i;

  if (p_node->p_buf == NULL) return false;
 3a4:	8c 85       	ldd	r24, Y+12	; 0x0c
 3a6:	9d 85       	ldd	r25, Y+13	; 0x0d
 3a8:	89 2b       	or	r24, r25
 3aa:	e9 f1       	breq	.+122    	; 0x426 <qbufferRead+0xa4>
 3ac:	aa 24       	eor	r10, r10
 3ae:	bb 24       	eor	r11, r11
 3b0:	65 01       	movw	r12, r10
 3b2:	32 c0       	rjmp	.+100    	; 0x418 <qbufferRead+0x96>


  for (i=0; i<length; i++)
  {
    index      = p_node->ptr_out;
 3b4:	2c 81       	ldd	r18, Y+4	; 0x04
 3b6:	3d 81       	ldd	r19, Y+5	; 0x05
 3b8:	4e 81       	ldd	r20, Y+6	; 0x06
 3ba:	5f 81       	ldd	r21, Y+7	; 0x07
    next_index = p_node->ptr_out + 1;
 3bc:	79 01       	movw	r14, r18
 3be:	8a 01       	movw	r16, r20
 3c0:	08 94       	sec
 3c2:	e1 1c       	adc	r14, r1
 3c4:	f1 1c       	adc	r15, r1
 3c6:	01 1d       	adc	r16, r1
 3c8:	11 1d       	adc	r17, r1

    if (next_index == p_node->length)
 3ca:	88 85       	ldd	r24, Y+8	; 0x08
 3cc:	99 85       	ldd	r25, Y+9	; 0x09
 3ce:	aa 85       	ldd	r26, Y+10	; 0x0a
 3d0:	bb 85       	ldd	r27, Y+11	; 0x0b
 3d2:	e8 16       	cp	r14, r24
 3d4:	f9 06       	cpc	r15, r25
 3d6:	0a 07       	cpc	r16, r26
 3d8:	1b 07       	cpc	r17, r27
 3da:	19 f4       	brne	.+6      	; 0x3e2 <qbufferRead+0x60>
 3dc:	ee 24       	eor	r14, r14
 3de:	ff 24       	eor	r15, r15
 3e0:	87 01       	movw	r16, r14
    {
      next_index = 0;
    }

    if (index != p_node->ptr_in)
 3e2:	88 81       	ld	r24, Y
 3e4:	99 81       	ldd	r25, Y+1	; 0x01
 3e6:	aa 81       	ldd	r26, Y+2	; 0x02
 3e8:	bb 81       	ldd	r27, Y+3	; 0x03
 3ea:	28 17       	cp	r18, r24
 3ec:	39 07       	cpc	r19, r25
 3ee:	4a 07       	cpc	r20, r26
 3f0:	5b 07       	cpc	r21, r27
 3f2:	c9 f0       	breq	.+50     	; 0x426 <qbufferRead+0xa4>
    {
      p_data[i]       = p_node->p_buf[index];
 3f4:	fb 01       	movw	r30, r22
 3f6:	ea 0d       	add	r30, r10
 3f8:	fb 1d       	adc	r31, r11
 3fa:	ac 85       	ldd	r26, Y+12	; 0x0c
 3fc:	bd 85       	ldd	r27, Y+13	; 0x0d
 3fe:	a2 0f       	add	r26, r18
 400:	b3 1f       	adc	r27, r19
 402:	8c 91       	ld	r24, X
 404:	80 83       	st	Z, r24
      p_node->ptr_out = next_index;
 406:	ec 82       	std	Y+4, r14	; 0x04
 408:	fd 82       	std	Y+5, r15	; 0x05
 40a:	0e 83       	std	Y+6, r16	; 0x06
 40c:	1f 83       	std	Y+7, r17	; 0x07
  uint32_t i;

  if (p_node->p_buf == NULL) return false;


  for (i=0; i<length; i++)
 40e:	08 94       	sec
 410:	a1 1c       	adc	r10, r1
 412:	b1 1c       	adc	r11, r1
 414:	c1 1c       	adc	r12, r1
 416:	d1 1c       	adc	r13, r1
 418:	a6 14       	cp	r10, r6
 41a:	b7 04       	cpc	r11, r7
 41c:	c8 04       	cpc	r12, r8
 41e:	d9 04       	cpc	r13, r9
 420:	48 f2       	brcs	.-110    	; 0x3b4 <qbufferRead+0x32>
 422:	81 e0       	ldi	r24, 0x01	; 1
 424:	01 c0       	rjmp	.+2      	; 0x428 <qbufferRead+0xa6>
 426:	80 e0       	ldi	r24, 0x00	; 0
      break;
    }
  }

  return ret;
}
 428:	df 91       	pop	r29
 42a:	cf 91       	pop	r28
 42c:	1f 91       	pop	r17
 42e:	0f 91       	pop	r16
 430:	ff 90       	pop	r15
 432:	ef 90       	pop	r14
 434:	df 90       	pop	r13
 436:	cf 90       	pop	r12
 438:	bf 90       	pop	r11
 43a:	af 90       	pop	r10
 43c:	9f 90       	pop	r9
 43e:	8f 90       	pop	r8
 440:	7f 90       	pop	r7
 442:	6f 90       	pop	r6
 444:	08 95       	ret

00000446 <qbufferAvailable>:

uint32_t qbufferAvailable(qbuffer_t *p_node)
{
 446:	ef 92       	push	r14
 448:	ff 92       	push	r15
 44a:	0f 93       	push	r16
 44c:	1f 93       	push	r17
 44e:	fc 01       	movw	r30, r24
  uint32_t length;


  length = (p_node->length + p_node->ptr_in - p_node->ptr_out) % p_node->length;
 450:	20 85       	ldd	r18, Z+8	; 0x08
 452:	31 85       	ldd	r19, Z+9	; 0x09
 454:	42 85       	ldd	r20, Z+10	; 0x0a
 456:	53 85       	ldd	r21, Z+11	; 0x0b
 458:	60 81       	ld	r22, Z
 45a:	71 81       	ldd	r23, Z+1	; 0x01
 45c:	82 81       	ldd	r24, Z+2	; 0x02
 45e:	93 81       	ldd	r25, Z+3	; 0x03
 460:	62 0f       	add	r22, r18
 462:	73 1f       	adc	r23, r19
 464:	84 1f       	adc	r24, r20
 466:	95 1f       	adc	r25, r21
 468:	e4 80       	ldd	r14, Z+4	; 0x04
 46a:	f5 80       	ldd	r15, Z+5	; 0x05
 46c:	06 81       	ldd	r16, Z+6	; 0x06
 46e:	17 81       	ldd	r17, Z+7	; 0x07
 470:	6e 19       	sub	r22, r14
 472:	7f 09       	sbc	r23, r15
 474:	80 0b       	sbc	r24, r16
 476:	91 0b       	sbc	r25, r17
 478:	0e 94 4d 02 	call	0x49a	; 0x49a <__udivmodsi4>

  return length;
}
 47c:	1f 91       	pop	r17
 47e:	0f 91       	pop	r16
 480:	ff 90       	pop	r15
 482:	ef 90       	pop	r14
 484:	08 95       	ret

00000486 <qbufferFlush>:

void qbufferFlush(qbuffer_t *p_node)
{
 486:	fc 01       	movw	r30, r24
  p_node->ptr_in  = 0;
 488:	10 82       	st	Z, r1
 48a:	11 82       	std	Z+1, r1	; 0x01
 48c:	12 82       	std	Z+2, r1	; 0x02
 48e:	13 82       	std	Z+3, r1	; 0x03
  p_node->ptr_out = 0;
 490:	14 82       	std	Z+4, r1	; 0x04
 492:	15 82       	std	Z+5, r1	; 0x05
 494:	16 82       	std	Z+6, r1	; 0x06
 496:	17 82       	std	Z+7, r1	; 0x07
}
 498:	08 95       	ret

0000049a <__udivmodsi4>:
 49a:	a1 e2       	ldi	r26, 0x21	; 33
 49c:	1a 2e       	mov	r1, r26
 49e:	aa 1b       	sub	r26, r26
 4a0:	bb 1b       	sub	r27, r27
 4a2:	fd 01       	movw	r30, r26
 4a4:	0d c0       	rjmp	.+26     	; 0x4c0 <__udivmodsi4_ep>

000004a6 <__udivmodsi4_loop>:
 4a6:	aa 1f       	adc	r26, r26
 4a8:	bb 1f       	adc	r27, r27
 4aa:	ee 1f       	adc	r30, r30
 4ac:	ff 1f       	adc	r31, r31
 4ae:	a2 17       	cp	r26, r18
 4b0:	b3 07       	cpc	r27, r19
 4b2:	e4 07       	cpc	r30, r20
 4b4:	f5 07       	cpc	r31, r21
 4b6:	20 f0       	brcs	.+8      	; 0x4c0 <__udivmodsi4_ep>
 4b8:	a2 1b       	sub	r26, r18
 4ba:	b3 0b       	sbc	r27, r19
 4bc:	e4 0b       	sbc	r30, r20
 4be:	f5 0b       	sbc	r31, r21

000004c0 <__udivmodsi4_ep>:
 4c0:	66 1f       	adc	r22, r22
 4c2:	77 1f       	adc	r23, r23
 4c4:	88 1f       	adc	r24, r24
 4c6:	99 1f       	adc	r25, r25
 4c8:	1a 94       	dec	r1
 4ca:	69 f7       	brne	.-38     	; 0x4a6 <__udivmodsi4_loop>
 4cc:	60 95       	com	r22
 4ce:	70 95       	com	r23
 4d0:	80 95       	com	r24
 4d2:	90 95       	com	r25
 4d4:	9b 01       	movw	r18, r22
 4d6:	ac 01       	movw	r20, r24
 4d8:	bd 01       	movw	r22, r26
 4da:	cf 01       	movw	r24, r30
 4dc:	08 95       	ret

000004de <_exit>:
 4de:	f8 94       	cli

000004e0 <__stop_program>:
 4e0:	ff cf       	rjmp	.-2      	; 0x4e0 <__stop_program>
